
.. _program_listing_file__Users_enrico_Ricerca_develop_C++_pins-mechatronix_LibSources_submodules_GC_src_GenericContainer.hh:

Program Listing for File GenericContainer.hh
============================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_enrico_Ricerca_develop_C++_pins-mechatronix_LibSources_submodules_GC_src_GenericContainer.hh>` (``/Users/enrico/Ricerca/develop/C++/pins-mechatronix/LibSources/submodules/GC/src/GenericContainer.hh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*--------------------------------------------------------------------------*\
    |                                                                          |
    |  Copyright (C) 2013                                                      |
    |                                                                          |
    |         , __                 , __                                        |
    |        /|/  \               /|/  \                                       |
    |         | __/ _   ,_         | __/ _   ,_                                |
    |         |   \|/  /  |  |   | |   \|/  /  |  |   |                        |
    |         |(__/|__/   |_/ \_/|/|(__/|__/   |_/ \_/|/                       |
    |                           /|                   /|                        |
    |                           \|                   \|                        |
    |                                                                          |
    |      Enrico Bertolazzi                                                   |
    |      Dipartimento di Ingegneria Industriale                              |
    |      Universita` degli Studi di Trento                                   |
    |      email: enrico.bertolazzi@unitn.it                                   |
    |                                                                          |
   \*--------------------------------------------------------------------------*/
   
   //
   // file: GenericContainer.hh
   //
   
   #ifndef GENERIC_CONTAINER_HH
   #define GENERIC_CONTAINER_HH
   
   #ifdef __clang__
   #pragma clang diagnostic push
   #pragma clang diagnostic ignored "-Wpadded"
   #pragma clang diagnostic ignored "-Wc++98-compat"
   #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
   #pragma clang diagnostic ignored "-Wpoison-system-directories"
   #endif
   
   #include <iostream>
   #include <string>
   #include <complex>
   #include <map>
   #include <deque>
   #include <vector>
   #include <sstream>
   #include <stdexcept>
   
   #include "GenericContainerConfig.hh"
   
   #ifndef GC_DO_ERROR
     #define GC_DO_ERROR(MSG) {                          \
       std::ostringstream ost;                           \
       GenericContainerNamespace::backtrace( ost );      \
       ost << "in GenericContainer: " << MSG << '\n';    \
       GenericContainer::exception( ost.str().c_str() ); \
     }
   #endif
   
   #ifndef GC_ASSERT
     #define GC_ASSERT(COND,MSG) if ( !(COND) ) GC_DO_ERROR(MSG)
   #endif
   
   #ifndef GC_WARNING
     #define GC_WARNING(COND,MSG)                                        \
       if ( !(COND) ) {                                                  \
         std::cout << "On line: " << __LINE__                            \
                   << " file: " << __FILE__                              \
                   << " in GenericContainer\nWARNING: " << MSG << '\n';  \
       }
   #endif
   
   #ifdef __GNUC__
     #define GC_NO_RETURN __attribute__ ((noreturn))
   #else
     #define GC_NO_RETURN
   #endif
   
   namespace GenericContainerNamespace {
   
     typedef std::basic_ostream<char> ostream_type;
   
     void backtrace( ostream_type & );
   
     #ifndef _MSC_VER
     using std::int32_t;
     using std::int64_t;
     using std::uint32_t;
     using std::uint64_t;
     #endif
   
     class GenericContainer;
   
     typedef void*                   pointer_type; 
     typedef bool                    bool_type;    
     typedef int32_t                 int_type;     
     typedef int64_t                 long_type;    
     typedef double                  real_type;    
     typedef std::complex<real_type> complex_type; 
     typedef std::string             string_type;  
   
     typedef std::vector<pointer_type> vec_pointer_type; 
     typedef std::vector<bool_type>    vec_bool_type;    
     typedef std::vector<int_type>     vec_int_type;     
     typedef std::vector<long_type>    vec_long_type;    
     typedef std::vector<real_type>    vec_real_type;    
     typedef std::vector<complex_type> vec_complex_type; 
     typedef std::vector<string_type>  vec_string_type;  
   
     typedef std::vector<GenericContainer>          vector_type; 
     typedef std::map<string_type,GenericContainer> map_type;    
   
     // ---------------------------------------------------------------------------
   
     typedef uint32_t uint_type;  
     typedef uint64_t ulong_type; 
   
     typedef std::vector<uint_type>  vec_uint_type;  
     typedef std::vector<ulong_type> vec_ulong_type; 
   
     // ---------------------------------------------------------------------------
     template <typename TYPE>
     class mat_type : public std::vector<TYPE> {
       unsigned m_numRows;
       unsigned m_numCols;
       typedef typename std::vector<TYPE>::size_type size_type;
     public:
   
       mat_type()
       : m_numRows(0)
       , m_numCols(0)
       {}
   
       mat_type( unsigned nr, unsigned nc )
       : m_numRows(nr)
       , m_numCols(nc)
       { std::vector<TYPE>::resize(size_type(nr*nc)); }
   
       void
       resize( unsigned nr, unsigned nc ) {
         m_numRows = nr;
         m_numCols = nc;
         std::vector<TYPE>::resize(size_type(nr*nc));
       }
   
       void getColumn( unsigned nc, std::vector<TYPE> & C ) const;
       void getRow( unsigned nr, std::vector<TYPE> & R ) const;
       void getColumn( unsigned nc, TYPE * C ) const;
       void getRow( unsigned nr, TYPE * R ) const;
   
       unsigned numRows() const { return m_numRows; }
       unsigned numCols() const { return m_numCols; }
   
       TYPE const & operator () ( unsigned i, unsigned j ) const;
       TYPE       & operator () ( unsigned i, unsigned j );
   
       void info( ostream_type & stream ) const;
   
       TYPE       * data()       { return &std::vector<TYPE>::front(); }
       TYPE const * data() const { return &std::vector<TYPE>::front(); }
     };
   
     // ---------------------------------------------------------------------------
   
     #ifndef GENERIC_CONTAINER_ON_WINDOWS
     extern template class mat_type<int_type>;
     extern template class mat_type<long_type>;
     extern template class mat_type<real_type>;
     extern template class mat_type<complex_type>;
     #endif
   
     typedef mat_type<int_type>     mat_int_type;
     typedef mat_type<long_type>    mat_long_type;
     typedef mat_type<real_type>    mat_real_type;
     typedef mat_type<complex_type> mat_complex_type;
   
     // ---------------------------------------------------------------------------
     template <typename TYPE>
     ostream_type & operator << ( ostream_type & s, std::vector<TYPE> const & v );
   
     template <typename TYPE>
     ostream_type & operator << ( ostream_type & s, mat_type<TYPE> const & );
     // ---------------------------------------------------------------------------
   
     enum TypeAllowed {
       // simple type
       GC_NOTYPE=0,
       GC_POINTER,
       GC_BOOL,
       GC_INTEGER,
       GC_LONG,
       GC_REAL,
       GC_COMPLEX,
       GC_STRING,
   
       // vector type
       GC_VEC_POINTER,
       GC_VEC_BOOL,
       GC_VEC_INTEGER,
       GC_VEC_LONG,
       GC_VEC_REAL,
       GC_VEC_COMPLEX,
       GC_VEC_STRING,
   
       // matrix type
       GC_MAT_INTEGER,
       GC_MAT_LONG,
       GC_MAT_REAL,
       GC_MAT_COMPLEX,
   
       // complex type
       GC_VECTOR,
       GC_MAP
     };
   
     class GenericContainer {
     public:
       // import type
       typedef GenericContainerNamespace::pointer_type     pointer_type;
       typedef GenericContainerNamespace::bool_type        bool_type;
       typedef GenericContainerNamespace::int_type         int_type;
       typedef GenericContainerNamespace::uint_type        uint_type;
       typedef GenericContainerNamespace::long_type        long_type;
       typedef GenericContainerNamespace::ulong_type       ulong_type;
       typedef GenericContainerNamespace::real_type        real_type;
       typedef GenericContainerNamespace::complex_type     complex_type;
       typedef GenericContainerNamespace::string_type      string_type;
       typedef GenericContainerNamespace::vec_pointer_type vec_pointer_type;
       typedef GenericContainerNamespace::vec_bool_type    vec_bool_type;
       typedef GenericContainerNamespace::vec_int_type     vec_int_type;
       typedef GenericContainerNamespace::vec_uint_type    vec_uint_type;
       typedef GenericContainerNamespace::vec_long_type    vec_long_type;
       typedef GenericContainerNamespace::vec_ulong_type   vec_ulong_type;
       typedef GenericContainerNamespace::vec_real_type    vec_real_type;
       typedef GenericContainerNamespace::vec_complex_type vec_complex_type;
       typedef GenericContainerNamespace::vec_string_type  vec_string_type;
       typedef GenericContainerNamespace::vector_type      vector_type;
       typedef GenericContainerNamespace::map_type         map_type;
       typedef GenericContainerNamespace::mat_int_type     mat_int_type;
       typedef GenericContainerNamespace::mat_long_type    mat_long_type;
       typedef GenericContainerNamespace::mat_real_type    mat_real_type;
       typedef GenericContainerNamespace::mat_complex_type mat_complex_type;
   
     private:
   
       typedef union {
         pointer_type     p;
         bool_type        b;
         int_type         i;
         long_type        l;
         real_type        r;
         complex_type     * c;
         string_type      * s;
   
         vec_pointer_type * v_p;
         vec_bool_type    * v_b;
         vec_int_type     * v_i;
         vec_long_type    * v_l;
         vec_real_type    * v_r;
         vec_complex_type * v_c;
         vec_string_type  * v_s;
   
         mat_int_type     * m_i;
         mat_long_type    * m_l;
         mat_real_type    * m_r;
         mat_complex_type * m_c;
   
         vector_type      * v;
         map_type         * m;
   
       } DataStorage;
   
       DataStorage m_data;      
       TypeAllowed m_data_type; 
   
       void allocate_string();
       void allocate_complex();
   
       void allocate_vec_pointer( unsigned sz );
       void allocate_vec_bool( unsigned sz );
       void allocate_vec_int( unsigned sz );
       void allocate_vec_long( unsigned sz );
       void allocate_vec_real( unsigned sz );
       void allocate_vec_complex( unsigned sz );
       void allocate_mat_int( unsigned nr, unsigned nc );
       void allocate_mat_long( unsigned nr, unsigned nc );
       void allocate_mat_real( unsigned nr, unsigned nc );
       void allocate_mat_complex( unsigned nr, unsigned nc );
       void allocate_vec_string( unsigned sz );
   
       void allocate_vector( unsigned sz );
       void allocate_map();
   
       void ck(char const [],TypeAllowed) const;
       int  ck(TypeAllowed) const;
       void ck_or_set(char const [], TypeAllowed);
   
       #ifdef GENERIC_CONTAINER_ON_WINDOWS
       bool simple_data()     const;
       bool simple_vec_data() const;
       #else
       bool simple_data()     const { return m_data_type <= GC_STRING; }
       bool simple_vec_data() const { return m_data_type <= GC_VEC_STRING; }
       #endif
   
     public:
   
       GenericContainer();
   
       ~GenericContainer() { clear(); }
   
       void clear();
   
   
       pointer_type & set_pointer( pointer_type value );
   
       GenericContainer & free_pointer();
   
       bool_type & set_bool( bool_type value );
   
       int_type & set_int( int_type value );
   
       long_type & set_long( long_type value );
   
       real_type & set_real( real_type value );
   
       complex_type & set_complex( complex_type & value );
   
       complex_type & set_complex( real_type r, real_type i );
   
       string_type & set_string( string_type const & value );
   
   
   
       vec_pointer_type & set_vec_pointer( unsigned sz = 0 );
   
       vec_pointer_type & set_vec_pointer( vec_pointer_type const & v );
   
       vec_bool_type & set_vec_bool( unsigned sz = 0 );
   
       vec_bool_type & set_vec_bool( vec_bool_type const & v );
   
       vec_int_type & set_vec_int( unsigned sz = 0 );
   
       vec_int_type & set_vec_int( vec_int_type const & v );
   
       vec_long_type & set_vec_long( unsigned sz = 0 );
   
       vec_long_type & set_vec_long( vec_long_type const & v );
   
       vec_real_type & set_vec_real( unsigned sz = 0 );
   
       vec_real_type & set_vec_real( vec_real_type const & v );
   
       vec_complex_type & set_vec_complex( unsigned sz = 0 );
   
       vec_complex_type & set_vec_complex( vec_complex_type const & v );
   
       vec_string_type & set_vec_string( unsigned sz = 0 );
   
       vec_string_type & set_vec_string( vec_string_type const & v );
   
       mat_int_type & set_mat_int( unsigned nr = 0, unsigned nc = 0 );
   
       mat_int_type & set_mat_int( mat_int_type const & m );
   
       mat_long_type & set_mat_long( unsigned nr = 0, unsigned nc = 0 );
   
       mat_long_type & set_mat_long( mat_long_type const & m );
   
       mat_real_type & set_mat_real( unsigned nr = 0, unsigned nc = 0 );
   
       mat_real_type & set_mat_real( mat_real_type const & m );
   
       mat_complex_type & set_mat_complex( unsigned nr = 0, unsigned nc = 0 );
   
       mat_complex_type & set_mat_complex( mat_complex_type const & m );
   
       void push_bool( bool );
   
       void push_int( int_type );
   
       void push_long( long_type );
   
       void push_real( real_type );
   
       void push_complex( complex_type & );
   
       void push_complex( real_type re, real_type im );
   
       void push_string( string_type const & );
   
   
   
   
       vector_type & set_vector( unsigned sz = 0 );
   
       map_type & set_map();
   
   
   
   
       TypeAllowed get_type() const { return m_data_type; }
   
       char const * get_type_name() const;
   
       GenericContainer const & info( ostream_type & stream ) const;
   
       unsigned get_num_elements() const;
   
       unsigned get_numRows() const;
   
       unsigned get_numCols() const;
   
       real_type get_number() const;
   
       complex_type get_complex_number() const;
   
       void get_complex_number( real_type & re, real_type & im ) const;
   
       void * get_pvoid( char const msg[] = nullptr ) const;
   
       void ** get_ppvoid( char const msg[] = nullptr ) const;
   
       int_type const * get_int_pointer() const;
   
       int_type * get_int_pointer();
   
       long_type const * get_long_pointer() const;
   
       long_type * get_long_pointer();
   
       real_type const * get_real_pointer() const;
   
       real_type * get_real_pointer();
   
       complex_type const * get_complex_pointer() const;
   
       complex_type * get_complex_pointer();
   
   
       template <typename T>
       void
       get_value( T & v, char const msg[] = "" ) const;
   
       #ifdef GENERIC_CONTAINER_ON_WINDOWS
       template <typename T>
       T& get_pointer()
       { ck("get_pointer",GC_POINTER); return *reinterpret_cast<T*>(get_ppvoid()); }
   
       template <typename T>
       T get_pointer() const
       { ck("get_pointer",GC_POINTER); return reinterpret_cast<T>(get_pvoid()); }
       #else
       template <typename T>
       T& get_pointer()
       { ck("get_pointer",GC_POINTER); return *reinterpret_cast<T*>(&(m_data.p)); }
   
       template <typename T>
       T get_pointer() const
       { ck("get_pointer",GC_POINTER); return reinterpret_cast<T>(m_data.p); }
       #endif
   
       bool_type
       get_map_bool( char const key[] ) const {
         bool_type ret = false;
         if ( exists(key) ) ret = (*this)(key).get_bool();
         return ret;
       }
   
       bool_type & get_bool( char const msg[] = nullptr );
   
       bool_type const & get_bool( char const msg[] = nullptr ) const;
   
       int_type & get_int( char const msg[] = nullptr );
   
       int_type const & get_int( char const msg[] = nullptr ) const;
   
       long_type & get_long( char const msg[] = nullptr );
   
       long_type const & get_long( char const msg[] = nullptr ) const;
   
       int_type get_as_int( char const msg[] = nullptr ) const;
   
       uint_type get_as_uint( char const msg[] = nullptr ) const;
   
       long_type get_as_long( char const msg[] = nullptr ) const;
   
       ulong_type get_as_ulong( char const msg[] = nullptr ) const;
   
       real_type & get_real( char const msg[] = nullptr );
   
       real_type const & get_real( char const msg[] = nullptr ) const;
   
       complex_type & get_complex( char const msg[] = nullptr );
   
       complex_type const & get_complex( char const msg[] = nullptr ) const;
   
       string_type & get_string( char const msg[] = nullptr );
   
       string_type const & get_string( char const msg[] = nullptr ) const;
   
   
   
       vector_type & get_vector( char const msg[] = nullptr );
   
       vector_type const & get_vector( char const msg[] = nullptr ) const;
   
       vec_pointer_type & get_vec_pointer( char const msg[] = nullptr );
   
       vec_pointer_type const & get_vec_pointer( char const msg[] = nullptr ) const;
   
       vec_bool_type & get_vec_bool( char const msg[] = nullptr );
   
       vec_bool_type const & get_vec_bool( char const msg[] = nullptr ) const;
   
       vec_int_type & get_vec_int( char const msg[] = nullptr );
   
       vec_int_type const & get_vec_int( char const msg[] = nullptr ) const;
   
       vec_long_type & get_vec_long( char const msg[] = nullptr );
   
       vec_long_type const & get_vec_long( char const msg[] = nullptr ) const;
   
       vec_real_type & get_vec_real( char const msg[] = nullptr );
   
       vec_real_type const & get_vec_real( char const msg[] = nullptr ) const;
   
       vec_complex_type & get_vec_complex( char const msg[] = nullptr );
   
       vec_complex_type const & get_vec_complex( char const msg[] = nullptr ) const;
   
       mat_int_type & get_mat_int( char const msg[] = nullptr );
   
       mat_int_type const & get_mat_int( char const msg[] = nullptr ) const;
   
       mat_long_type & get_mat_long( char const msg[] = nullptr );
   
       mat_long_type const & get_mat_long( char const msg[] = nullptr ) const;
   
       mat_real_type & get_mat_real( char const msg[] = nullptr );
   
       mat_real_type const & get_mat_real( char const msg[] = nullptr ) const;
   
       mat_complex_type & get_mat_complex( char const msg[] = nullptr );
   
       mat_complex_type const & get_mat_complex( char const msg[] = nullptr ) const;
   
       vec_string_type & get_vec_string( char const msg[] = nullptr );
   
       vec_string_type const & get_vec_string( char const msg[] = nullptr ) const;
   
   
   
       void copyto_vec_int( vec_int_type & v, char const msg[] = "" ) const;
   
       void copyto_vec_uint( vec_uint_type & v, char const msg[] = "" ) const;
   
       void copyto_vec_long( vec_long_type & v, char const msg[] = "" ) const;
   
       void copyto_vec_ulong( vec_ulong_type & v, char const msg[] = "" ) const;
   
       void copyto_vec_real( vec_real_type & v, char const msg[] = "" ) const;
   
       void copyto_vec_complex( vec_complex_type & v, char const msg[] = "" ) const;
   
       void copyto_vec_string( vec_string_type & v, char const msg[] = "" ) const;
   
   
   
   
       real_type get_number_at( unsigned i ) const;
   
       complex_type get_complex_number_at( unsigned i ) const;
   
       void get_complex_number_at( unsigned i, real_type & re, real_type & im ) const;
   
       template <typename T>
       T& get_pointer_at( unsigned i )
       { return (*this)[i].get_pointer<T>(); }
   
       template <typename T>
       T get_pointer_at( unsigned i ) const
       { return (*this)[i].get_pointer<T>(); }
   
       bool_type get_bool_at( unsigned i );
   
       bool_type get_bool_at( unsigned i, char const msg[] ) const;
   
       int_type & get_int_at( unsigned i );
   
       int_type const & get_int_at( unsigned i, char const msg[] ) const;
   
       long_type & get_long_at( unsigned i );
   
       long_type const & get_long_at( unsigned i, char const msg[] ) const;
   
       real_type & get_real_at( unsigned i );
   
       real_type const & get_real_at( unsigned i, char const msg[] ) const;
    
       complex_type & get_complex_at( unsigned i );
   
       complex_type const & get_complex_at( unsigned i, char const msg[] ) const;
   
       int_type & get_int_at( unsigned i, unsigned j );
   
       int_type const & get_int_at( unsigned i, unsigned j, char const msg[] ) const;
   
       long_type & get_long_at( unsigned i, unsigned j );
   
       long_type const & get_long_at( unsigned i, unsigned j, char const msg[] ) const;
   
       real_type & get_real_at( unsigned i, unsigned j );
   
       real_type const & get_real_at( unsigned i, unsigned j, char const msg[] ) const;
   
       complex_type & get_complex_at( unsigned i, unsigned j );
   
       complex_type const & get_complex_at( unsigned i, unsigned j, char const msg[] ) const;
   
       string_type & get_string_at( unsigned i );
   
       string_type const & get_string_at( unsigned i, char const msg[] ) const;
   
       GenericContainer & get_gc_at( unsigned i );
   
       GenericContainer const & get_gc_at( unsigned i, char const msg[] ) const;
   
   
   
   
       map_type & get_map( char const msg[] = nullptr );
   
       map_type const & get_map( char const msg[] = nullptr ) const;
   
   
   
   
       GenericContainer & operator [] ( unsigned i );
   
       GenericContainer const & operator [] ( unsigned i ) const;
   
       GenericContainer & operator [] ( std::string const & s );
   
       GenericContainer const & operator [] ( std::string const & s ) const;
   
       GenericContainer & operator () ( unsigned i, char const msg[] = nullptr );
   
       GenericContainer const & operator () ( unsigned i, char const msg[] = nullptr ) const;
   
       GenericContainer & operator () ( std::string const & s, char const msg[] = nullptr );
   
       GenericContainer const & operator () ( std::string const & s, char const msg[] = nullptr ) const;
   
   
   
       void set( bool const & a ) { this->set_bool(a); }
   
       void set( uint_type const & a ) { this->set_int(int_type(a)); }
   
       void set( int_type const & a ) { this->set_int(a); }
   
       void set( ulong_type const & a ) { this->set_long(long_type(a)); }
   
       void set( long_type const & a ) { this->set_long(a); }
   
       void set( float const & a ) { this->set_real(real_type(a)); }
   
       void set( double const & a ) { this->set_real(real_type(a)); }
   
       void set( std::complex<float> const & a )
       { this->set_complex(real_type(a.real()),real_type(a.imag())); }
   
       void set( std::complex<double> const & a )
       { this->set_complex(real_type(a.real()),real_type(a.imag())); }
   
       void set( char const a[] ) { this->set_string(a); }
   
       void set( std::string const & a ) { this->set_string(a); }
   
       void set( pointer_type a ) { this->set_pointer(a); }
   
   
   
   
       GenericContainer & operator = ( bool const & a )
       { this->set_bool(a); return * this; }
   
       GenericContainer & operator = ( uint_type const & a )
       { this->set_int(int_type(a)); return * this; }
   
       GenericContainer & operator = ( int_type const & a )
       { this->set_int(a); return * this; }
   
       GenericContainer & operator = ( ulong_type const & a )
       { this->set_long(long_type(a)); return * this; }
   
       GenericContainer & operator = ( long_type const & a )
       { this->set_long(a); return * this; }
   
       GenericContainer & operator = ( float const & a )
       { this->set_real(real_type(a)); return * this; }
   
       GenericContainer & operator = ( double const & a )
       { this->set_real(real_type(a)); return * this; }
   
       GenericContainer & operator = ( std::complex<float> const & a )
       { this->set_complex(real_type(a.real()),real_type(a.imag())); return * this; }
   
       GenericContainer & operator = ( std::complex<double> const & a )
       { this->set_complex(real_type(a.real()),real_type(a.imag())); return * this; }
   
       GenericContainer & operator = ( vec_bool_type const & a );
   
       GenericContainer & operator = ( vec_int_type const & a );
   
       GenericContainer & operator = ( vec_long_type const & a );
   
       GenericContainer & operator = ( vec_real_type const & a );
   
       GenericContainer & operator = ( vec_complex_type const & a );
   
       GenericContainer & operator = ( vec_string_type const & a );
   
       GenericContainer & operator = ( mat_int_type const & a );
   
       GenericContainer & operator = ( mat_long_type const & a );
   
       GenericContainer & operator = ( mat_real_type const & a );
   
       GenericContainer & operator = ( mat_complex_type const & a );
   
       GenericContainer & operator = ( char const a[] )
       { this->set_string(a); return * this; }
   
       GenericContainer & operator = ( std::string const & a )
       { this->set_string(a); return * this; }
   
       GenericContainer & operator = ( pointer_type a )
       { this->set_pointer(a); return * this; }
   
       GenericContainer const & operator = ( GenericContainer const & a )
       { this->load( a ); return * this; }
   
       void load( GenericContainer const & a );
   
   
       GenericContainer const & promote_to_int();
   
       GenericContainer const & promote_to_long();
   
       GenericContainer const & promote_to_real();
   
       GenericContainer const & promote_to_complex();
   
       GenericContainer const & promote_to_vec_int();
   
       GenericContainer const & promote_to_vec_long();
   
       GenericContainer const & promote_to_vec_real();
   
       GenericContainer const & promote_to_vec_complex();
   
       GenericContainer const & promote_to_mat_int();
   
       GenericContainer const & promote_to_mat_long();
   
       GenericContainer const & promote_to_mat_real();
   
       GenericContainer const & promote_to_mat_complex();
   
       GenericContainer const & promote_to_vector();
   
   
   
   
       GenericContainer( bool const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( uint_type const & a )
       : m_data_type(GC_NOTYPE) { *this = a; }
   
       GenericContainer( int_type const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( ulong_type const & a )
       : m_data_type(GC_NOTYPE) { *this = a; }
   
       GenericContainer( long_type const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( float const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( double const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( std::complex<float> const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( std::complex<double> const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( char const a[] )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( std::string const & a )
       : m_data_type(GC_NOTYPE) { this->operator=(a); }
   
       GenericContainer( pointer_type a )
       : m_data_type(GC_NOTYPE) { this->set_pointer(a); }
   
       GenericContainer( GenericContainer const & gc )
       : m_data_type(GC_NOTYPE) { this->load(gc); }
   
   
   
       bool exists( std::string const & s ) const;
   
       bool get_if_exists( char const field[], bool & value ) const;
   
       bool get_if_exists( char const field[], int_type & value ) const;
   
       bool get_if_exists( char const field[], uint_type & value ) const;
   
       bool get_if_exists( char const field[], long_type & value ) const;
   
       bool get_if_exists( char const field[], ulong_type & value ) const;
   
       bool get_if_exists( char const field[], real_type & value ) const;
   
       bool get_if_exists( char const field[], complex_type & value ) const;
   
       bool get_if_exists( char const field[], string_type & value ) const;
   
   
   
   
       void
       print_content_types(
         ostream_type      & stream,
         std::string const & prefix = "",
         std::string const & indent = "    "
       ) const;
   
       void
       dump(
         ostream_type      & stream,
         std::string const & prefix = "",
         std::string const & indent = "    "
       ) const;
   
       void
       print(
         ostream_type      & stream,
         std::string const & prefix = "",
         std::string const & indent = "    "
       ) const {
         this->dump( stream, prefix, indent );
       }
   
       void to_yaml( ostream_type & stream, std::string const & prefix = "" ) const;
   
       GenericContainer const &
       writeFormattedData( ostream_type & stream, char const delimiter = '\t' ) const;
   
       GenericContainer &
       readFormattedData(
         std::istream & stream,
         char const commentChars[] = "#%",
         char const delimiters[] = " \t"
       );
   
       GenericContainer &
       readFormattedData(
         char const fname[],
         char const commentChars[] = "#%",
         char const delimiters[] = " \t"
       );
   
       static
       void
       exception( char const msg[] ) GC_NO_RETURN;
   
     };
   
     // -------------------------------------------------------
     // support functions
     void
     writeTable(
       vec_string_type const & headers,
       vector_type     const & data,
       ostream_type          & stream,
       char const delimiter = '\t'
     );
   
     void
     writeTable(
       vec_string_type const & headers,
       mat_real_type   const & data,
       ostream_type          & stream,
       char const delimiter = '\t'
     );
   
     void
     writeTableFormatted(
       vec_string_type const & headers,
       vector_type     const & data,
       ostream_type          & stream
     );
   
     void
     writeTableFormatted(
       vec_string_type const & headers,
       mat_real_type   const & data,
       ostream_type          & stream
     );
   
     // -------------------------------------------------------
     class GenericContainerExplorer {
     private:
       enum {
         GENERIC_CONTAINER_OK        = 0,
         GENERIC_CONTAINER_BAD_TYPE  = 1,
         GENERIC_CONTAINER_NO_DATA   = 2,
         GENERIC_CONTAINER_NOT_EMPTY = 3,
         GENERIC_CONTAINER_BAD_HEAD  = 4
       };
   
       GenericContainer              data;
       std::deque<GenericContainer*> head;
   
       map_type         * ptr_map;
       map_type::iterator map_iterator;
   
     public:
   
       GenericContainerExplorer() { head.push_back(&data); }
       ~GenericContainerExplorer() {}
   
       GenericContainer *
       top() {
         GC_ASSERT(
           head.size() > 0,
           "GenericContainerExplorer::top() empty stack!"
         )
         GC_ASSERT(
           head.back() != nullptr,
           "GenericContainerExplorer::top() bad top pointer!"
         )
         return head.back();
       }
   
       GenericContainer const *
       top() const {
         GC_ASSERT(
           head.size() > 0,
           "GenericContainerExplorer::top() empty stack!"
         )
         GC_ASSERT(
           head.back() != nullptr,
           "GenericContainerExplorer::top() bad top pointer!"
         )
         return head.back();
       }
   
       void       * mem_ptr()       { return &data; }
       void const * mem_ptr() const { return &data; }
   
       int
       check( int data_type ) const {
         if ( head.empty() ) return GENERIC_CONTAINER_BAD_HEAD;
         if ( data_type == head.back()->get_type() ) {
           if ( head.back() == nullptr ) return GENERIC_CONTAINER_NO_DATA;
           return GENERIC_CONTAINER_OK;
         } else {
           return GENERIC_CONTAINER_BAD_TYPE;
         }
       }
   
       int
       check_no_data( int data_type ) const {
         if ( head.empty() ) return GENERIC_CONTAINER_BAD_HEAD;
         if ( GC_NOTYPE == head.back()->get_type() ||
              data_type == head.back()->get_type() ) return GENERIC_CONTAINER_OK;
         return GENERIC_CONTAINER_NOT_EMPTY;
       }
   
       int
       pop() {
         if ( head.empty() ) return GENERIC_CONTAINER_NO_DATA;
         head.pop_back();
         return GENERIC_CONTAINER_OK;
       }
   
       int
       push( GenericContainer * gc ) {
         head.push_back( gc );
         return GENERIC_CONTAINER_OK;
       }
   
       int
       push_vector_position( unsigned pos ) {
         int ok = check( GC_VECTOR );
         if ( ok == GENERIC_CONTAINER_OK  ) {
           GenericContainer * gc = &((*head.back())[pos]);
           head.push_back( gc );
         }
         return ok;
       }
   
       int
       push_map_position( char const pos[] ) {
         int ok = check( GC_MAP );
         if ( ok == GENERIC_CONTAINER_OK  ) {
           GenericContainer * gc = &((*head.back())[pos]);
           head.push_back( gc );
         }
         return ok;
       }
   
       int
       init_map_key() {
         int ok = check( GC_MAP );
         if ( ok == GENERIC_CONTAINER_OK ) {
           ptr_map = &head.back()->get_map();
           map_iterator = ptr_map->begin();
         }
         return ok;
       }
   
       char const *
       next_map_key() {
         if ( map_iterator != ptr_map->end() )
           return map_iterator++->first.c_str();
         else
           return nullptr;
       }
   
       int
       reset() {
         if ( head.empty() ) return GENERIC_CONTAINER_NO_DATA;
         while ( head.size() > 1 ) head.pop_back();
         return GENERIC_CONTAINER_OK;
       }
   
     };
   }
   
   // do not define alias GC if use X11
   #ifndef XlibSpecificationRelease
   namespace GC = GenericContainerNamespace;
   #endif
   
   #ifdef __clang__
   #pragma clang diagnostic pop
   #endif
   
   #endif
   
   //
   // eof: GenericContainer.hh
   //
